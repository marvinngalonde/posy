import crypto from 'crypto'
import { PrismaClient } from '@prisma/client'
import type {
  ZIMRAConfig,
  FiscalDevice,
  ZIMRAInvoiceData,
  ZIMRAResponse,
  FiscalReceiptItem,
  QRCodeData,
  ZIMRAError
} from './types'

const prisma = new PrismaClient()

export class ZIMRAClient {
  private config: ZIMRAConfig
  private device: FiscalDevice | null = null

  constructor(config: ZIMRAConfig) {
    this.config = config
  }

  async initialize(): Promise<void> {
    // Load fiscal device
    this.device = await this.loadFiscalDevice()

    if (!this.device) {
      throw new Error('No active fiscal device found')
    }
  }

  private async loadFiscalDevice(): Promise<FiscalDevice | null> {
    const device = await prisma.fiscal_devices.findFirst({
      where: {
        zimra_config_id: this.config.id,
        status: 'Active'
      }
    })

    if (!device) return null

    return {
      id: device.id,
      zimraConfigId: device.zimra_config_id,
      deviceId: device.device_id,
      deviceSerialNo: device.device_serial_no,
      branchName: device.branch_name,
      branchAddress: device.branch_address as any,
      operatingMode: device.operating_mode as 'Online' | 'Offline',
      status: device.status as 'Active' | 'Blocked' | 'Pending',
      dailyReceiptCounter: device.daily_receipt_counter,
      globalReceiptCounter: BigInt(device.global_receipt_counter.toString()),
      fiscalDayOpened: device.fiscal_day_opened || undefined,
      lastZReport: device.last_z_report || undefined
    }
  }

  async submitFiscalInvoice(invoiceData: ZIMRAInvoiceData): Promise<ZIMRAResponse> {
    if (!this.device) {
      throw new Error('ZIMRA client not initialized')
    }

    try {
      // Check if FDMS is enabled
      if (!this.config.isFDMSEnabled) {
        return this.handleNonFDMSMode(invoiceData)
      }

      // Ensure fiscal day is open
      await this.ensureFiscalDayOpen()

      // Get next global receipt number
      const receiptGlobalNo = await this.getNextGlobalReceiptNo()

      // Build fiscal invoice
      const fiscalInvoice = this.buildFiscalInvoice(invoiceData, receiptGlobalNo)

      // Generate device signature
      fiscalInvoice.deviceSignature = this.generateDeviceSignature(fiscalInvoice)

      // Submit to ZIMRA (if online mode)
      if (this.device.operatingMode === 'Online') {
        const response = await this.submitToZIMRA(fiscalInvoice)

        // Generate QR code
        const qrCodeData = await this.generateQRCode(response)

        // Store transaction
        await this.storeFiscalTransaction(fiscalInvoice, response, qrCodeData)

        return {
          success: true,
          receiptGlobalNo: receiptGlobalNo,
          qrCodeData: qrCodeData,
          fdmsSignature: response.fdmsSignature,
          verificationUrl: `${process.env.ZIMRA_VERIFICATION_URL || 'https://fdms.zimra.co.zw'}/verify?code=${response.verificationCode}`
        }
      } else {
        // Offline mode - queue transaction
        await this.queueOfflineTransaction(fiscalInvoice)
        const offlineQR = await this.generateOfflineQRCode(fiscalInvoice)

        return {
          success: true,
          receiptGlobalNo: receiptGlobalNo,
          qrCodeData: offlineQR,
          status: 'offline_queued',
          message: 'Transaction queued for submission when online'
        }
      }

    } catch (error: any) {
      console.error('ZIMRA submission error:', error)

      // Handle network errors by going offline
      if (error.code === 'ECONNREFUSED' || error.code === 'ENOTFOUND') {
        return this.handleOfflineMode(invoiceData)
      }

      throw error
    }
  }

  private handleNonFDMSMode(invoiceData: ZIMRAInvoiceData): ZIMRAResponse {
    // In non-FDMS mode, we still generate a receipt number and basic QR code
    // but don't submit to ZIMRA
    const receiptNo = Date.now() // Simple receipt number for non-FDMS

    const basicQR = {
      data: {
        deviceId: 'NON-FDMS',
        receiptNo: BigInt(receiptNo),
        total: invoiceData.total,
        date: new Date().toISOString(),
        verification: 'NON-FDMS-MODE'
      },
      qrString: JSON.stringify({
        mode: 'NON-FDMS',
        receiptNo: receiptNo,
        total: invoiceData.total,
        date: new Date().toISOString()
      }),
      qrCodeUrl: '' // Will be generated by frontend
    }

    return {
      success: true,
      receiptGlobalNo: BigInt(receiptNo),
      qrCodeData: basicQR,
      status: 'non_fdms_mode',
      message: 'Receipt generated in non-FDMS mode'
    }
  }

  private async handleOfflineMode(invoiceData: ZIMRAInvoiceData): Promise<ZIMRAResponse> {
    const receiptGlobalNo = await this.getNextGlobalReceiptNo()
    const fiscalInvoice = this.buildFiscalInvoice(invoiceData, receiptGlobalNo)

    await this.queueOfflineTransaction(fiscalInvoice)
    const offlineQR = await this.generateOfflineQRCode(fiscalInvoice)

    return {
      success: true,
      receiptGlobalNo: receiptGlobalNo,
      qrCodeData: offlineQR,
      status: 'offline_queued',
      message: 'Network error - Transaction queued for submission when online'
    }
  }

  private buildFiscalInvoice(invoiceData: ZIMRAInvoiceData, receiptGlobalNo: bigint): any {
    return {
      receiptType: 'FiscalInvoice',
      deviceID: this.device!.deviceId,
      receiptGlobalNo: receiptGlobalNo.toString(),
      invoiceNo: invoiceData.invoiceNo,
      receiptCurrency: invoiceData.currency || 'USD',
      receiptTotal: parseFloat(invoiceData.total.toString()).toFixed(2),
      receiptDate: new Date().toISOString(),
      taxpayerTIN: this.config.taxpayerTIN,
      buyerTIN: invoiceData.customer?.tin || null,
      buyerName: invoiceData.customer?.name || null,
      receiptItems: invoiceData.items.map(item => ({
        itemName: item.name,
        itemQuantity: item.quantity,
        itemPrice: parseFloat(item.price.toString()).toFixed(2),
        itemTotal: parseFloat((item.quantity * item.price).toString()).toFixed(2),
        taxPercent: item.taxRate || 15.0,
        taxID: item.taxId || 1,
        HSCode: item.hsCode || '0000'
      })),
      taxAmount: this.calculateTotalTax(invoiceData.items),
      deviceSignature: '' // Will be set later
    }
  }

  private calculateTotalTax(items: ZIMRAInvoiceData['items']): string {
    const totalTax = items.reduce((total, item) => {
      const itemTotal = item.quantity * item.price
      const taxRate = item.taxRate || 15.0
      return total + (itemTotal * taxRate / 100)
    }, 0)

    return totalTax.toFixed(2)
  }

  private generateDeviceSignature(fiscalInvoice: any): string {
    // Simple signature generation for demo - in production use proper certificate
    const signatureString = [
      fiscalInvoice.deviceID,
      fiscalInvoice.receiptGlobalNo,
      fiscalInvoice.receiptDate,
      fiscalInvoice.receiptTotal,
      this.config.taxpayerTIN
    ].join('|')

    const secret = process.env.DEVICE_SIGNATURE_SECRET || 'default-secret'
    return crypto.createHmac('sha256', secret).update(signatureString).digest('hex')
  }

  private async submitToZIMRA(fiscalInvoice: any): Promise<any> {
    // Mock ZIMRA API response - replace with actual ZIMRA API call
    console.log('Submitting to ZIMRA API:', fiscalInvoice.deviceID, fiscalInvoice.receiptGlobalNo)

    // Simulate API delay
    await new Promise(resolve => setTimeout(resolve, 1000))

    if (this.config.testEnvironment) {
      return {
        success: true,
        fdmsSignature: `ZIMRA_${Date.now()}`,
        verificationCode: `V${fiscalInvoice.receiptGlobalNo}`,
        timestamp: new Date().toISOString()
      }
    }

    throw new Error('Production ZIMRA API not implemented')
  }

  private async generateQRCode(zimraResponse: any): Promise<any> {
    const qrData = {
      deviceId: this.device!.deviceId,
      receiptNo: BigInt(zimraResponse.receiptGlobalNo || Date.now()),
      total: parseFloat(zimraResponse.receiptTotal || '0'),
      date: zimraResponse.timestamp || new Date().toISOString(),
      verification: zimraResponse.verificationCode
    }

    return {
      data: qrData,
      qrString: JSON.stringify(qrData),
      qrCodeUrl: '' // Will be generated by frontend component
    }
  }

  private async generateOfflineQRCode(fiscalInvoice: any): Promise<any> {
    const qrData = {
      deviceId: fiscalInvoice.deviceID,
      receiptNo: BigInt(fiscalInvoice.receiptGlobalNo),
      total: parseFloat(fiscalInvoice.receiptTotal),
      date: fiscalInvoice.receiptDate,
      verification: 'OFFLINE_MODE'
    }

    return {
      data: qrData,
      qrString: JSON.stringify(qrData),
      qrCodeUrl: ''
    }
  }

  private async ensureFiscalDayOpen(): Promise<void> {
    if (!this.device) return

    const today = new Date().toISOString().split('T')[0]
    const deviceDay = this.device.fiscalDayOpened?.toISOString().split('T')[0]

    if (!this.device.fiscalDayOpened || deviceDay !== today) {
      // Open new fiscal day
      await prisma.fiscal_devices.update({
        where: { device_id: this.device.deviceId },
        data: {
          fiscal_day_opened: new Date(),
          daily_receipt_counter: 0
        }
      })

      console.log(`Fiscal day opened for device ${this.device.deviceId}`)
    }
  }

  private async getNextGlobalReceiptNo(): Promise<bigint> {
    if (!this.device) throw new Error('No device available')

    const updated = await prisma.fiscal_devices.update({
      where: { device_id: this.device.deviceId },
      data: {
        global_receipt_counter: { increment: 1 },
        daily_receipt_counter: { increment: 1 }
      }
    })

    return BigInt(updated.global_receipt_counter.toString())
  }

  private async storeFiscalTransaction(fiscalInvoice: any, zimraResponse: any, qrCodeData: any): Promise<void> {
    await prisma.fiscal_transactions.create({
      data: {
        zimra_config_id: this.config.id,
        device_id: fiscalInvoice.deviceID,
        receipt_global_no: BigInt(fiscalInvoice.receiptGlobalNo),
        receipt_type: fiscalInvoice.receiptType,
        invoice_no: fiscalInvoice.invoiceNo,
        receipt_currency: fiscalInvoice.receiptCurrency,
        receipt_total: parseFloat(fiscalInvoice.receiptTotal),
        tax_amount: parseFloat(fiscalInvoice.taxAmount),
        receipt_date: new Date(fiscalInvoice.receiptDate),
        buyer_tin: fiscalInvoice.buyerTIN,
        buyer_name: fiscalInvoice.buyerName,
        receipt_items: fiscalInvoice.receiptItems,
        device_signature: fiscalInvoice.deviceSignature,
        fdms_signature: zimraResponse.fdmsSignature,
        qr_code_data: JSON.stringify(qrCodeData),
        zimra_status: 'confirmed'
      }
    })
  }

  private async queueOfflineTransaction(fiscalInvoice: any): Promise<void> {
    await prisma.offline_fiscal_queue.create({
      data: {
        zimra_config_id: this.config.id,
        device_id: fiscalInvoice.deviceID,
        transaction_data: fiscalInvoice,
        status: 'pending'
      }
    })
  }
}

export class ZIMRAManager {
  static async getZIMRAConfig(): Promise<ZIMRAConfig | null> {
    const config = await prisma.zimra_config.findFirst({
      where: { status: 'active' }
    })

    if (!config) return null

    return {
      id: config.id,
      taxpayerTIN: config.taxpayer_tin,
      vatRegistrationNo: config.vat_registration_no || undefined,
      businessName: config.business_name,
      businessType: config.business_type,
      branchName: config.branch_name,
      branchAddress: config.branch_address as any,
      deviceCertificatePath: config.device_certificate_path || undefined,
      certificateThumbprint: config.certificate_thumbprint || undefined,
      certificateExpiry: config.certificate_expiry || undefined,
      testEnvironment: config.test_environment,
      apiEndpoint: config.api_endpoint || undefined,
      status: config.status as any,
      isFDMSEnabled: config.is_fdms_enabled
    }
  }

  static async createZIMRAClient(): Promise<ZIMRAClient | null> {
    const config = await this.getZIMRAConfig()
    if (!config) return null

    const client = new ZIMRAClient(config)
    await client.initialize()
    return client
  }

  static async isFDMSEnabled(): Promise<boolean> {
    const config = await this.getZIMRAConfig()
    return config?.isFDMSEnabled || false
  }
}